C51 COMPILER V9.59.0.0   SEPTEMPERATUE                                                     06/23/2024 16:14:28 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE SEPTEMPERATUE
OBJECT MODULE PLACED IN septemperatue.OBJ
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE septemperatue.c BROWSE DEBUG OBJECTEXTEND

line level    source

   1          #include <reg51.h>
   2          #include <absacc.h>
   3          
   4          // 定义数据类型
   5          #define u8  unsigned char
   6          #define u16 unsigned int
   7          #define u32 unsigned long  
   8          
   9          // 定义端口
  10          #define DT_DA_PORT XBYTE[0xe400]     // 数码管数据端口
  11          #define DT_DI_PORT XBYTE[0xe800]
  12          #define PWM_OUT_PORT XBYTE[0xc400]   // 传感器及PWM输出端口
  13          #define SPT_LOW_INPORT XBYTE[0xc100]
  14          #define SPT_HIG_INPORT XBYTE[0xc200]
  15          
  16          // 设定值
  17          int SetValue;
  18          
  19          // PID控制参数 (调整这些参数以获得更好的性能)
  20          float Kp = 0.5f;
  21          float Ki = 0.01f;
  22          float Kd = 0.1f;
  23          
  24          // 误差变量
  25          int et;
  26          int et_1;
  27          int et_2;
  28          
  29          // PID积分和微分项
  30          float integral = 0.0f;
  31          float derivative = 0.0f;
  32          
  33          // PWM变量
  34          static float pwm = 0.0f;  
  35          
  36          // 显示缓冲区
  37          u8 DispBuff[8] = {0, 0, 0, 0, 1, 1, 1, 7};
  38          
  39          // 串口接收缓冲区
  40          u8 ReceiveCounts = 0; 
  41          u8 Re_Buff[6];
  42          
  43          // 温度数据
  44          u16 temperature = 0;
  45          
  46          // 发送温度数据的计数器
  47          u16 send_counter = 0;
  48          
  49                           
  50          // 发送一个字节
  51          void send_byte(u8 dat) {
  52   1          SBUF = dat;
  53   1          while(!TI);
  54   1          TI = 0;
  55   1      }
C51 COMPILER V9.59.0.0   SEPTEMPERATUE                                                     06/23/2024 16:14:28 PAGE 2   

  56          
  57          // 发送温度数据
  58          void send_temperature() {
  59   1          send_byte(0x55);  // 起始字节
  60   1          send_byte(0x00);
  61   1          send_byte(0x00);
  62   1          send_byte((u8)(temperature >> 8));  // 高字节
  63   1          send_byte((u8)(temperature));  // 低字节
  64   1          send_byte(0xaa);  // 结束字节
  65   1      }
  66          
  67          // 发送确认帧
  68          void send_confirmation() {
  69   1          send_byte(0x55); 
  70   1          send_byte(0x06); 
  71   1          send_byte(0x00);
  72   1          send_byte(0x00);
  73   1          send_byte(0x00);
  74   1          send_byte(0xaa);
  75   1      }
  76          
  77          // 串口中断服务函数
  78          void serial_isr() interrupt 4 {
  79   1          if (RI) {
  80   2              RI = 0;
  81   2              Re_Buff[ReceiveCounts++] = SBUF;
  82   2              
  83   2              if (ReceiveCounts == 6) {
  84   3                  ReceiveCounts = 0;
  85   3                  
  86   3                  // 处理设置温度值的命令
  87   3                  if ((Re_Buff[0] == 0x55) && (Re_Buff[1] == 0x01) && (Re_Buff[5] == 0xaa)) {
  88   4                      SetValue = (Re_Buff[3] << 8) | Re_Buff[4];
  89   4                      integral = 0; // 重置积分项
  90   4                      send_confirmation();
  91   4                  }
  92   3                  // 处理设置PID参数的命令
  93   3                  else if ((Re_Buff[0] == 0x55) && (Re_Buff[1] == 0x02) && (Re_Buff[5] == 0xaa)) {
  94   4                      Kp = Re_Buff[2] / 10.0;
  95   4                      Ki = Re_Buff[3] / 100.0;
  96   4                      Kd = Re_Buff[4] / 10.0;
  97   4                  }
  98   3              }
  99   2          }
 100   1          
 101   1          if (TI) {
 102   2              TI = 0;
 103   2          }
 104   1      }
 105          
 106          
 107          // 主函数
 108          void main() {
 109   1          // 串口初始化
 110   1          SCON = 0x50;    
 111   1          TMOD = 0x20;
 112   1          TL1 = TH1 = 0xFD;    // 9600 baud @ 11.0592MHz
 113   1          TR1 = 1;
 114   1              
 115   1          // 中断初始化
 116   1          IT0 = 1;
 117   1          IT1 = 1;
C51 COMPILER V9.59.0.0   SEPTEMPERATUE                                                     06/23/2024 16:14:28 PAGE 3   

 118   1          EX0 = 1;
 119   1          EX1 = 1;
 120   1          ES = 1;  // 使能串口中断
 121   1          EA = 1;  // 使能全局中断
 122   1          
 123   1          // 设定值初始化
 124   1          SetValue = 5000;  
 125   1              
 126   1          while (1) {
 127   2              // 周期性发送温度数据
 128   2              if (++send_counter >= 10000) {  // 减小发送间隔，提高响应速度
 129   3                  send_counter = 0;
 130   3                  send_temperature();
 131   3              }
 132   2          }
 133   1      }
 134          
 135          // 外部中断0服务函数
 136          void int0_isr() interrupt 0 {
 137   1          u16 x;
 138   1          float pid_output;
 139   1      
 140   1          // 读取传感器数据
 141   1          *((u8 *)&x + 1) = SPT_LOW_INPORT;
 142   1          *((u8 *)&x + 0) = SPT_HIG_INPORT;
 143   1          
 144   1          // 更新温度数据
 145   1          temperature = x;
 146   1          
 147   1          // 计算误差
 148   1          et_2 = et_1;
 149   1          et_1 = et;
 150   1          et = SetValue - (int)x;
 151   1      
 152   1          // 计算积分项 (使用梯形积分法)
 153   1          integral += (et + et_1) / 2.0f;
 154   1          
 155   1          // 应用积分限幅，防止积分饱和
 156   1          if (integral > 1000) integral = 1000;
 157   1          if (integral < -1000) integral = -1000;
 158   1      
 159   1          // 计算微分项
 160   1          derivative = et - et_1;
 161   1      
 162   1          // PID控制算法
 163   1          pid_output = Kp * et + Ki * integral + Kd * derivative;
 164   1      
 165   1          // 更新PWM值
 166   1          pwm += pid_output;
 167   1      
 168   1          // PWM限幅
 169   1          if (pwm > 255) pwm = 255;
 170   1          if (pwm < 0) pwm = 0;
 171   1      
 172   1          // 输出PWM
 173   1          PWM_OUT_PORT = (u8)pwm;
 174   1      
 175   1          // 更新显示缓冲区
 176   1          DispBuff[2] = x / 100000;
 177   1          x = x % 100000;
 178   1          DispBuff[3] = x / 10000;
 179   1          x = x % 10000;
C51 COMPILER V9.59.0.0   SEPTEMPERATUE                                                     06/23/2024 16:14:28 PAGE 4   

 180   1          DispBuff[4] = x / 1000;
 181   1          x = x % 1000;
 182   1          DispBuff[5] = x / 100;
 183   1          x = x % 100;
 184   1          DispBuff[6] = x / 10;
 185   1          x = x % 10;
 186   1          DispBuff[7] = x;
 187   1      }
 188          
 189          // 外部中断1服务函数
 190          void int1_isr() interrupt 2 {
 191   1          static u8 CurrentBit = 0x01;
 192   1      
 193   1          // 数码管显示编码
 194   1          u8 code SevenSegCode[10] = {0x3F, 0x06, 0x5B, 0x4F, 0x66, 0x6D, 0x7D, 0x07, 0x7F, 0x6F};
 195   1          u8 code SevenSegBT[8] = {0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80};
 196   1              
 197   1          DT_DI_PORT = 0;
 198   1          DT_DA_PORT = SevenSegCode[DispBuff[CurrentBit]];
 199   1          DT_DI_PORT = SevenSegBT[CurrentBit];
 200   1              
 201   1          CurrentBit++;
 202   1          CurrentBit = CurrentBit % 8;
 203   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1005    ----
   CONSTANT SIZE    =     18    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     52       6
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
